------------------------------------------------------
NOTES SUMMARY
------------------------------------------------------

** TIPS **
	> fetch(url): To get JSON results from API as a promise
	> console.table()
	> console.error()
	> an_array.map((o,i) => {});
	> an_array.filter(o => o> VALUE);
	> Object.freeze(object)
		It will prevent you from modifying an object property
		const person = {name: 'Juan'}; 
		person.name = 'JuanH'; //(this is allowed)
		Object.freeze(person);
		person.name = 'JuanHB';// (this is not allowed)
	> document.querySelector('. / #');
	> document.querySelectorAll('. / #');
	> Use Array.from(querySelectorAll) to convert a NodeList that comes from a document.querySelectorAll
	> any_element.addEventListener('the_event_like_click', function(){});\
	> any_element.classList.toggle('class_name')
	> any_element.textContent
	> any_element.classList.contains('class_name')
	> any_element.classList.contains('class_name')	
	> Creating HTML elements:	
		const info = document.querySelector('.info');
		const description = document.createElement('p');
		description.innerHTML = 'My name is blabla';
		info.appendChild(description);
	> dompurify to sanitize your code:
		<script src='http://cdnjs.cloudflare.com/ajax/libs/dompurify/0.8.2/purify.min.js'></script>
	> arguments is a KEYWORD IN A FUNCTION!!!!! It is a sort of array with all the arguments passed

** VAR / CONST / LET **
	- var can be used before they are defined, but they are UNDEFINED, it wont throw an error
	- let/const will throw an error if used before being declared 
	- var is functon scoped, NOT block scoped ( by {} ) !!!!!
	- IIFE
		(function(){
			var name = 'abc'; // THIS NAME IS NOT USED OUTSIDE OF THIS FILE
							  // IT IS CONSTRAINED TO THIS FUNCTION	
		})();

		{
			let letters = 'abc'; 
			const other_letters = 'abc'; // these variables dont leak outside {}
		}
	- you can declare several times the same variable with var!!. 
	- let wont allow you to have the same variable name declared twice
	- let/const are scoped to {}  (that is, blocked scope)
	- use let inside loops, as they are blocked scope regardless of the content inside (time, ajax blocks)
	- const cant be changed, but it is not immutable:
		> const person = {name: 'Juan'}; person.name = 'JuanH'; (this is allowed)

** ARROW FUNCTIONS **
	- They have implicit return and does not rebind THIS.
	- this inside the arrow function is inherited from the parent. 
		> Beware when using 'this' as the element in use
		> It will come handy to not use that (instead of this)
	- function(){//blabla} ---> () => {//blabla} ---> (arg1, arg2) ==> {//blabla with arg1 arg2}
	- Implicit return: If not using {} in one liner it will return that line
		() => names; // names will be returned
		// Put names inside () if its an object like ()
	}
	- They can be assigned to variables:
		const saymyname = (name) => { alert(`Hellow $(name)`)};
		saymyname('Juan');
	- Not to use arrow functions when:
		> When you need to use 'this'
		> When you need to add a method bind to an object (and therefore you will have to use 'this')
		> If you need to use the keyword 'arguments'. Arguments is a keyword in 'functions' that returns an array with all the arguments passed. This keyword does not exist for arrow functions

** DEFAULT ARGUMENTS IN FUNCTIONS
	- function sayaword(anyword = 'Hello World!') {}
	- It is possible to use/pass undefined and javascript will use the default
		function computenumbers(first = 1,second = 2,third = 3){//blblbla}
		computenunbers(10,undefined, 25); // second will have the value of 2

** TEMPLATE STRINGS
	- `This is an string with a ${variable}`
	- Multilines:
		> Previously we had to use the \ charactor for multiline. With `` you can just enter a new line
		const multiline=` first line
							second line
						`;
		const previously = 'First line \
							Second line'
	- It is possible to write js code inside ${} and nest ``
		const dogs = [{name:'Ted',age: 5},{name:'Bob',age: 3},{name:'Sugus',age: 2}];
		const markup = `
			<ul>
			${dogs.map(dog => `
				<li>
				${dog.name} (${dog.age*6})
				</li>
				`)}
			</ul>
		`;
	- Othe example nesting and writing JS code
		const dog_a = {name:'Ted',owner:'Juan'};
		const dog_b = {name:'Toby'};
		${dog_a.name }, owned by ${dog_a.owner};
		// If there is no owner, we can wrap some code ino a ${} and use again a `` and ${} to display a value
		${dog_a.name } ${dog_a.owner ? `, ${dog_a.owner}` }
	- You can even use a function inside the `` to render other `` to make things cleaner.
	- Tagged functions -- Instead of the browser populating the tags, you can have a funciton to do the same, or make any modification internally,or even using the values as keys for a dictionary. The function gets an array with all the bits plus all the variables.
		And most importantly, usa this to SANITIZE!!!!
	  const sentence = function_name`Text 1 ${var1} text 2 ${var2}`;
			function function_name(sentences,...values)
			{
				let str = '';
				str = sentences.forEach((string, i) => {
					str += string + values[i] || '';
				});
				return str;
				/*

				sentences.reduce((sentence, string, i) => {
					return `${sentence}${string}${values[i] || ''}`
				}), '');

				*/
			}
	- Sanitizing your code:
		<script src='http://cdnjs.cloudflare.com/ajax/libs/dompurify/0.8.2/purify.min.js'></script>
		function sanitize(strings,...values)
		{
			const dirty = sentences.reduce((sentence, string, i) => {
					return `${sentence}${string}${values[i] || ''}`
				}), '');
			return DOMPurify.sanitize(dirty);
		}
		sanitize`Code with <img src='theimag' onload='alert('badcode')'>`;

** STRINGS NEW METHODS
	- .startsWith(string_to_look,number_caracters_to_look_after)
	- .endsWith(string_to_look,number_caracters_to_crop_string_to)
	- .includes()
	- .repeat() // Can be used to left pad 

** DESTRUCTURING
	- 	const person = {name:'Juan',age:50};
		const {name, age:theAge} = person; // This is equivalent to const name = person.name; const theAge = person.age;
		const {name, age:theAge, lastname: thelastname = 'defaultValue'} = person; // If person does not have a lastname property, i twill use the defaultValue into a property called thelastname
	- Destructuring array:
		const person = ['Juan',39,'Computer Science'];
		const [name, age, major] = person; // It will assign each component to those variables
		const team = ['Juan','Hasmin','Miguel','Sofia'];
		const [father,mather,...children] = team;
	- Swaping objects
		const one = 1; const two = 2;
		[one,two]  =[two,one];
	- Functions with args in any order and with default values:
		function tip({amount, tip = 20, tax = 0.13}){//blablabla};
		var amount = tip({tip : 10, amount: 5 });

** entries == ITERATOR OF ARRAY
	// entries retursn an iterator, with a next and a done properties.
	var names = ['Juan','Miguel','Sofia'];
	for(const [value,index] of names.entries())
	{

	}

** FOR IN (Loop)
	- Returns the index
	- It includes new things added to the array (not only the elements in the array, but also new properties or methods added!)

** FOR OF (Loop)
	- Best alternative for loops (foreach, for in or plain for loop)
	- Can have continue, break
	- Nice way of looping for array or other arrayish objects
	- It cant be used in Objects! ==> conts applee = {color: 'red', size: 10};
	- To be used with objects:
		> Polifill and use entries 
		> Use for in loop and use the key to get the value: object[key];
	- Or, to be used wiht objexts, you can use keys (Object.keys(array_name));

** Array methods
	- Array.from(object, mappingFunction): Convert an arrayish into an array
	- Array.of(o1,o2,o3,o4) : Build an array out of values
	- an_array.find(): an_array.find(el => { el.property === 'value'})
		> For multiple findings, use filter
	- an_array.findIndex: an_array.findIndex(el => { el.property === 'value'}) : From the element, return the index in 	the array
	- an_array.some(el => el === 'value'): Returns true if ANY element matches the condition
	- an_array.every(el => el === 'value'): Returns true if EVENRY element matches the condition

** Spread Operator (...values)
	- Applied over any iterable (arrays, strings, dom nodes ,arguments, objects ...)
	- It will SPREAD an array into elements, which can be grouped back into an array
	- [...array1,'el2',...array3] : This will concatenate arrays
	- Can be use to copy (deep copy) an array: let new_array = [...old_array];
	- [...arrayish] is equivalent to Array.from(arraish);

** Rest Operator (...values)
	- Used in grouping parameters in function definition ( function functionName(first, ...restParameters))
	- Used also in destructuring [first, second, restOfNumbers] = [1,2,3,4,5,6,7,8,9];

** Object Literals:
	- If using a variable to create an object, no need to specify the property name if the variable name is the same:
		> 	var name = 'Juan';
			let person = {name: name}
			let person_2 = {name}
			// Person and person person_2 are equivalent
		>	var modal = { mymethod: function(){//blah blah blah}} ;
			var modal_2 = { mymethod() {//blah blah blah}} ;
			// modal and modal_2 are equivalent
	- Computer Property Name: 
		> 	const key = 'color';
			const value = 'blue';
			const valueNegative = 'red';
			const pants = { [key]: value,[${key}Negative]: value};
			// ${key}Negative: It is possible to compute key values

** Promises
	- A value-to-be in the future
	- Usage:
		> 	promise.then(toDoWhenDataIsReturned).catch(err => {console.log(err)});
			function toDoWhenDataIsReturned(data)
			{
				var jsonData = data.json(); //Important to convert data into json!!!
			}
	- Creating a promise:
		>	const myPromise = new Promise((resolve,reject) => {
				// Check if it should be OK
				resolve('here_the_object_data_to_return');
				// Check if it should be OK
				reject('here_the_object_err_to_return');
			});

			myPromise.then( data => {console.log(data)}) // data will be the 'here_the_object_data_to_return'
					 .catch(err => {console.log(err)}); // err will be the 'here_the_object_err_to_return'
	- Promises.All([promise1,promise2]).then(responses => { // responses is an array with one response per promise})

** Symbol (new primitive)
	- Symbol: Unique identifier out of descriptor at a unique time. Same descriptor, different symbols
	- Useful to create unique identifiers as keys
	- It is not possible to loop over an array of symbols:
		> 	var syms = Object.getownPropertySymbls(arryayOfSymbols); // This is possible
			const data = sysm.map(s => arryayOfSymbols[s]);

** ESLint
	- Installation:
		> 	node and npm are installed (node -v and npm -v are working
		> 	npm install -g eslint
		> 	npm install -g eslint-plugin-html
			npm install -g eslint-config-airbnb
			npm install -g eslint-plugin-jsx-a11y
			npm install -g eslint-plugin-react
			npm install eslint-plugin-import -g
		> create .eslintrc for settings
		> use airbnb style: "extends": "airbnb"
			* Check github site: https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb
			* TIP: npm install -g eslint-config-airbnb eslint-plugin-import eslint-plugin-react eslint-plugin-jsx-a11y
		> run: eslint file_to_check --fix
		> Add a global .eslintrc globally in your home directory (this will be completely overriden by a local .eslintrc)
		> Per file, you can enable or disable rules. For the whole file, or per line (enabling and disabling in the following line)
			/* globals var_name */ // This will specify global variables in a file
			/* eslint-disable eslint-rule-goes-here*/
			/* eslint-enable eslint-rule-goes-here*/
			/* eslint-disabld */ // It will completely disable ALL THE ESLINT!
		> Plugin     x: To lint the JS code inside HTML
		> Sublime plugin:
			* Install SublimeLinter AND SublimeLinter-contrib-lint
		> Create hook in git to prevent submit code when does not comply with eslint




